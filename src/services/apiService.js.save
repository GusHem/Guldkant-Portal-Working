// üîß PERFECT apiService.js - Guldkant Portal v2.0
// NordSym Atom-Smed: Kirurgiskt precis f√∂r CREATE/UPDATE operations

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'https://nordsym.app.n8n.cloud/webhook';

// üõ°Ô∏è ENHANCED ERROR HANDLING & REQUEST UTILITY
async function makeRequest(url, options = {}) {
    const defaultOptions = {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            ...options.headers
        }
    };

    const requestOptions = { ...defaultOptions, ...options };

    try {
        console.log(`üîó API Request: ${requestOptions.method} ${url}`);
        if (requestOptions.body) {
            console.log('üì§ Request payload:', JSON.parse(requestOptions.body));
        }
        
        const response = await fetch(url, requestOptions);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const contentType = response.headers.get('content-type');
        
        if (contentType && contentType.includes('application/json')) {
            try {
                const data = await response.json();
                console.log(`‚úÖ API Response:`, data);
                return data;
            } catch (parseError) {
                console.error('‚ùå JSON parsing failed:', parseError);
                const textResponse = await response.text();
                console.error('üìÑ Raw response:', textResponse);
                throw new Error('Ogiltigt JSON-svar fr√•n servern');
            }
        } else {
            // Non-JSON responses (f√∂r vissa n8n webhook responses)
            const textResponse = await response.text();
            console.log(`‚úÖ Non-JSON Response:`, textResponse);
            return { 
                status: 'success', 
                message: 'Operation genomf√∂rd',
                rawResponse: textResponse 
            };
        }
    } catch (networkError) {
        console.error(`‚ùå Network error for ${url}:`, networkError);
        throw new Error(`N√§tverksfel: ${networkError.message}`);
    }
}

// üéØ GULDKANT API SERVICE - PERFEKT VERSION
const apiService = {
    
    // üìä H√ÑMTA ALLA OFFERTER (GET /quotes)
    fetchQuotes: async () => {
        try {
            console.log('üìä Fetching all quotes from Airtable...');
            
            const data = await makeRequest(`${API_BASE_URL}/quotes`);
            
            // Hantera olika response format fr√•n n8n
            let quotes = [];
            if (data.quotes && Array.isArray(data.quotes)) {
                quotes = data.quotes;
            } else if (Array.isArray(data)) {
                quotes = data;
            } else {
                console.warn('‚ö†Ô∏è Unexpected response format:', data);
                quotes = [];
            }
            
            console.log(`‚úÖ Successfully fetched ${quotes.length} quotes`);
            return quotes;
            
        } catch (error) {
            console.error('‚ùå Error fetching quotes:', error);
            throw new Error(`Kunde inte h√§mta offerter: ${error.message}`);
        }
    },

    // üíæ SPARA/UPPDATERA OFFERT (POST /guldkant-offer-intake-v2)
    saveQuote: async (quoteData) => {
        try {
            console.log('üíæ Saving quote to Airtable via n8n...');
            
            // Validera essential data
            if (!quoteData || typeof quoteData !== 'object') {
                throw new Error('Ogiltig quote data');
            }

            // üîß SMART MODE DETECTION
            let mode = 'auto'; // L√•t n8n's Smart Logic best√§mma
            
            // Om quote har rawId eller befintligt id = UPDATE
            if (quoteData.rawId || (quoteData.id && quoteData.id.startsWith('GULDKANT-'))) {
                mode = 'update';
                console.log('üîÑ Detected UPDATE mode for existing quote');
            }
            // F√∂r helt nya quotes = CREATE  
            else if (!quoteData.id || quoteData.customer === 'Nytt √§rende') {
                mode = 'create';
                console.log('üÜï Detected CREATE mode for new quote');
                
                // Ta bort eventuellt tomt/placeholder ID f√∂r CREATE
                if (quoteData.id && (quoteData.id === '' || quoteData.id === 'new')) {
                    delete quoteData.id;
                }
                if (quoteData.offertId && (quoteData.offertId === '' || quoteData.offertId === 'new')) {
                    delete quoteData.offertId;
                }
            }

            // L√§gg till mode i payload f√∂r n8n Smart Logic
            const payload = {
                ...quoteData,
                mode: mode,
                timestamp: new Date().toISOString()
            };

            // üéØ ANV√ÑND KORREKT ENDPOINT - guldkant-offer-intake-v2
            const response = await makeRequest(`${API_BASE_URL}/guldkant-offer-intake-v2`, {
                method: 'POST',
                body: JSON.stringify(payload)
            });

            console.log('‚úÖ Quote saved successfully');
            return response;
            
        } catch (error) {
            console.error('‚ùå Error saving quote:', error);
            throw new Error(`Kunde inte spara offert: ${error.message}`);
        }
    },

    // üîÑ EXPLICIT UPDATE FUNKTION (f√∂r klarhet)
    updateQuote: async (offertId, updateData) => {
        try {
            console.log(`üîÑ Updating quote ${offertId}...`);
            
            if (!offertId) {
                throw new Error('OffertId kr√§vs f√∂r uppdatering');
            }

            const payload = {
                ...updateData,
                offertId: offertId,
                mode: 'update', // Explicit UPDATE mode
                timestamp: new Date().toISOString()
            };

            const response = await makeRequest(`${API_BASE_URL}/guldkant-offer-intake-v2`, {
                method: 'POST',
                body: JSON.stringify(payload)
            });

            console.log('‚úÖ Quote updated successfully');
            return response;
            
        } catch (error) {
            console.error('‚ùå Error updating quote:', error);
            throw new Error(`Kunde inte uppdatera offert: ${error.message}`);
        }
    },

    // üìã KOPIERA OFFERT (skapa ny baserad p√• befintlig)
    copyQuote: async (sourceId, newQuoteData = {}) => {
        try {
            console.log(`üìã Copying quote from ${sourceId}...`);
            
            if (!sourceId) {
                throw new Error('SourceId kr√§vs f√∂r kopiering');
            }

            const payload = {
                ...newQuoteData,
                sourceId: sourceId,
                mode: 'copy', // Explicit COPY mode f√∂r n8n
                status: 'utkast', // Nya kopior b√∂rjar som utkast
                timestamp: new Date().toISOString()
            };

            const response = await makeRequest(`${API_BASE_URL}/guldkant-offer-intake-v2`, {
                method: 'POST',
                body: JSON.stringify(payload)
            });

            console.log('‚úÖ Quote copied successfully');
            return response;
            
        } catch (error) {
            console.error('‚ùå Error copying quote:', error);
            throw new Error(`Kunde inte kopiera offert: ${error.message}`);
        }
    },

    // üéØ H√ÑMTA SPECIFIK OFFERT (implementeras via fetchQuotes + filter)
    getQuoteById: async (offertId) => {
        try {
            console.log(`üîç Fetching quote ${offertId}...`);
            
            if (!offertId) {
                throw new Error('OffertId kr√§vs');
            }

            // H√§mta alla och filtrera (enkel implementation)
            const allQuotes = await apiService.fetchQuotes();
            const quote = allQuotes.find(q => q.id === offertId || q.kundNamn === offertId);
            
            if (!quote) {
                throw new Error(`Offert ${offertId} hittades inte`);
            }
            
            console.log('‚úÖ Quote found');
            return quote;
            
        } catch (error) {
            console.error('‚ùå Error fetching quote by ID:', error);
            throw new Error(`Kunde inte h√§mta offert ${offertId}: ${error.message}`);
        }
    },

    // üìß SKICKA OFFERT VIA EMAIL (implementeras senare)
    sendProposal: async (quote) => {
        try {
            console.log('üìß Sending proposal...');
            
            if (!quote || !quote.email) {
                throw new Error('Quote och email kr√§vs f√∂r att skicka f√∂rslag');
            }

            const payload = { 
                rawId: quote.rawId, 
                id: quote.id,
                customerEmail: quote.email,
                action: 'send_proposal'
            };
            
            // TODO: Implementera n√§r email-workflow finns
            const response = await makeRequest(`${API_BASE_URL}/quote/dispatch`, {
                method: 'POST',
                body: JSON.stringify(payload)
            });
            
            console.log('‚úÖ Proposal sent successfully');
            return response;
            
        } catch (error) {
            console.error('‚ùå Error sending proposal:', error);
            throw new Error(`Kunde inte skicka f√∂rslag: ${error.message}`);
        }
    },

    // üóëÔ∏è ARKIVERA OFFERT (status update till arkiverad)
    deleteQuote: async (offertId) => {
        try {
            console.log(`üóëÔ∏è Archiving quote ${offertId}...`);
            
            if (!offertId) {
                throw new Error('OffertId kr√§vs f√∂r arkivering');
            }

            // Uppdatera status till arkiverad ist√§llet f√∂r att delete
            const response = await apiService.updateQuote(offertId, {
                status: 'arkiverad',
                archivedAt: new Date().toISOString()
            });
            
            console.log('‚úÖ Quote archived successfully');
            return response;
            
        } catch (error) {
            console.error('‚ùå Error archiving quote:', error);
            throw new Error(`Kunde inte arkivera offert: ${error.message}`);
        }
    },

    // üè• API HEALTH CHECK
    healthCheck: async () => {
        try {
            console.log('üè• Checking API health...');
            
            // Testa h√§mta quotes f√∂r att verifiera att API fungerar
            const quotesResponse = await makeRequest(`${API_BASE_URL}/quotes`);
            
            const healthStatus = {
                status: 'healthy',
                timestamp: new Date().toISOString(),
                apiUrl: API_BASE_URL,
                endpoints: {
                    fetchQuotes: true,
                    saveQuote: true // Antar att det fungerar om fetch fungerar
                },
                totalQuotes: quotesResponse.total || quotesResponse.quotes?.length || 0
            };
            
            console.log('‚úÖ API health check passed');
            return healthStatus;
            
        } catch (error) {
            console.error('‚ùå API health check failed:', error);
            
            return {
                status: 'unhealthy',
                timestamp: new Date().toISOString(),
                apiUrl: API_BASE_URL,
                error: error.message,
                endpoints: {
                    fetchQuotes: false,
                    saveQuote: false
                }
            };
        }
    },

    // üîß DEVELOPMENT & DEBUG UTILITIES
    debugApiCall: async (endpoint, method = 'GET', data = null) => {
        console.log(`üîß DEBUG: Testing ${method} ${endpoint}`);
        
        try {
            const options = method === 'GET' ? {} : {
                method,
                body: JSON.stringify(data)
            };
            
            const response = await makeRequest(`${API_BASE_URL}${endpoint}`, options);
            console.log('‚úÖ DEBUG Success:', response);
            return response;
            
        } catch (error) {
            console.error('‚ùå DEBUG Failed:', error);
            throw error;
        }
    },

    // üö® USER-FRIENDLY ERROR HANDLER
    handleApiError: (error, context = 'API operation') => {
        console.error(`‚ùå ${context} failed:`, error);
        
        // Returnera user-friendly error meddelanden
        if (error.message.includes('fetch') || error.message.includes('Network')) {
            return 'N√§tverksfel: Kunde inte n√• servern. Kontrollera din internetanslutning.';
        } else if (error.message.includes('404')) {
            return 'Resursen kunde inte hittas. Kontakta support om problemet kvarst√•r.';
        } else if (error.message.includes('500')) {
            return 'Serverfel: F√∂rs√∂k igen senare eller kontakta support.';
        } else if (error.message.includes('403')) {
            return '√Ötkomst nekad: Du har inte beh√∂righet f√∂r denna operation.';
        } else {
            return `Fel: ${error.message}`;
        }
    }
};

// üì§ EXPORT BOTH DEFAULT AND NAMED EXPORTS
export default apiService;

// Named exports f√∂r flexibility
export const {
    fetchQuotes,
    saveQuote,
    updateQuote,
    copyQuote,
    getQuoteById,
    sendProposal,
    deleteQuote,
    healthCheck,
    debugApiCall,
    handleApiError
} = apiService;